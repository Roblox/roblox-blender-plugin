# Copyright © 2023 Roblox Corporation

# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
# associated documentation files (the “Software”), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do
# so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all copies or substantial
# portions of the Software.

# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
# OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# SPDX-License-Identifier: MIT

# AUTHORIZATION FLOW:
#  1. We generate a PKCE code verifier
#  2. We generate a PKCE code challenge by encrypting code verifier
#  3. We generate an OAuth2 state
#  4. We make a GET request via browser for an authentication code, including the code challenge and state
#  5. We start a local server listening for a "response" (request to our local server)
#  6. User authorizes the requested scopes via browser, and gets redirected to our local server
#  7. We read the state and authentication code from the "response" (request to our local server)
#  8. We ensure the state from the "response" matches the state we sent with the authentication request, to prevent CSRF attacks
#       by verifying the response is to our authorization request, not originating from another malicious app
#  9. We make a POST request to the authentication server requesting an access token, including the code verifier and the authentication code
# 10. The authentication server encrypts our code verifier with the same algorithm and ensures it matches the code challenge
#       sent with our authentication request earlier. This ensures the access token request originated from us,
#       and not someone who intercepted our authorization code.
# 11. The authentication server responds to our request with an access token, refresh token, id token, etc.
# 12. We read profile information from the id token, perform actions (i.e. upload) with the access token, and get a new tokens with the
#       refresh token when the access token expires.
# 13. In order to remember the login, we store the refresh token invisibly in add-on preferences,
#       and use it in the next session to get new tokens.
# 14. If the user logs out, we make a POST request including the refresh token to revoke all tokens associated with this session.
#       We also clear the refresh token from add-on preference memory.

if "bpy" in locals():
    # Imports have run before. Need to reload the imported modules
    import importlib

    if "aiohttp" in locals():
        print("Reloading aiohttp")
        importlib.reload(aiohttp)
    if "web" in locals():
        print("Reloading web")
        importlib.reload(web)
    if "event_loop" in locals():
        importlib.reload(event_loop)
    if "request_login_details" in locals():
        importlib.reload(request_login_details)
    if "AuthCallbackRequestHandler" in locals():
        importlib.reload(AuthCallbackRequestHandler)
    if "create_http_client" in locals():
        importlib.reload(create_http_client)
    if "constants" in locals():
        importlib.reload(constants)

import bpy
import webbrowser
import asyncio
from secrets import token_urlsafe
from hashlib import sha256
from base64 import urlsafe_b64encode
from urllib.parse import urlencode, urljoin
from contextlib import asynccontextmanager
from time import time


PORT = 8080
HOST = "localhost"
RESPONSE_TYPE = "code"
CODE_CHALLENGE_METHOD = "S256"
CODE_LENGTH = 128  # PKCE spec is between 43 and 128
STATE_LENGTH = 128  # OAuth2 spec doesn't recommend a length, so this is a secure length


def generate_pkce_pair():
    """
    Generates a pair of PKCE code verifier and challenge,
    code verifier is a unique and non-guessable value generated by this app,
    and code challenge is generated by encrypting the code verifier.
    returns: tuple of (code_verifier, code_challenge)
    """
    # Create a cryptographically random url-safe string of PKCE-compliant length.
    # 96 bytes are needed to create 128 characters, the maximum PKCE allows

    new_code_verifier = token_urlsafe(96)[:CODE_LENGTH]

    # PKCE code challenges are encrypted code verifiers.
    # sha256 takes bytes, so we encode the string first, encrypt the bytes,
    # then digest the hash back into bytes

    code_challenge_bytes = sha256(new_code_verifier.encode("ascii")).digest()

    # If the number of bytes aren't a multiple of 3, encoding in base 64 pads the end of the string with `=`
    # Remove any padding (since it's not a valid PKCE code verifier character) and decode it back into a string

    new_code_challenge = urlsafe_b64encode(code_challenge_bytes).rstrip(b"=").decode("ascii")
    return new_code_verifier, new_code_challenge


def generate_state():
    """
    Generates a unique and non-guessable value to be used as the OAuth2 state parameter,
    which protects against CSRF attacks.
    returns: state string
    """
    # OAuth2 uses state to protect against CSRF attacks. This app generates a unique and non-guessable value
    # and sends it with the authentication request. If the response does not contain the same state,
    # it indicates the response is meant not for the authentication request we made and is rejected.
    from secrets import token_urlsafe

    new_state = token_urlsafe(96)[:STATE_LENGTH]
    return new_state


class LoginError(Exception):
    """
    Raised when an error occurs during the login process.
    """


class NotLoggedInError(Exception):
    """
    Raised when an active login session is required but not found.
    """


class RbxOAuth2Client:
    _instance = None
    token_data = {}

    def __new__(cls, *args, **kwargs):
        # Makes this class into a singleton
        if not cls._instance:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self, rbx):
        self.rbx = rbx

    async def login(self):
        """
        Starts the OAuth2 authorization flow by generating necessary security parameters and
        opening the auth URL in a web browser. Starts a local server listening for the user to be redirected
        back to it after authorizing the requested scopes. Populates token_data if successful, otherwise raises an exception.
        """
        async with self.__set_is_processing_login():
            from . import auth_callback_request_handler

            code_verifier, code_challenge = generate_pkce_pair()
            state = generate_state()
            handler = auth_callback_request_handler.AuthCallbackRequestHandler(self.rbx, state, code_verifier)

            # Application uses the default event loop returned by get_event_loop(),
            # and we want to ensure it uses the event loop we created in event_loop.py
            # in case get_event_loop would return a different loop created by another
            # plugin that is not being stepped
            from . import event_loop, constants

            asyncio.set_event_loop(event_loop.get_loop())
            import aiohttp.web as web

            app = web.Application()
            app.add_routes([web.get(f"/{constants.RELATIVE_REDIRECT_PATH.lstrip('/')}", handler.handle_request)])
            runner = web.AppRunner(app)

            # Start a web server on a localhost port
            try:
                await runner.setup()
                site = web.TCPSite(runner, host=HOST, port=PORT)
                await site.start()

                # Open the authorization URL in the user's browser
                webbrowser.open(self.__construct_auth_url(state, code_challenge))

                # Wait for one request to be handled (the callback from the OAuth2 server)
                await handler.request_handled_event.wait()
            finally:
                await runner.cleanup()

            # The aiohttp web app calls the handler which must return a response to the browser, so any exceptions occurring
            # during request handling are converted to an http response and sent to the browser. In order to get login
            # exception details in this context, we store in the event a copy of any exceptions, and re-raise it in this context.
            if hasattr(handler.request_handled_event, "exception"):
                raise LoginError from handler.request_handled_event.exception
            self.__complete_login(*handler.request_handled_event.login_details)

    async def logout(self):
        """
        Logs out the user by revoking all tokens associated with the session and clearing the token data.
        """
        refresh_token = self.token_data.get("refresh_token")
        if not refresh_token:
            raise NotLoggedInError("An active login session is required to log out")

        from . import constants

        revoke_token_request_data = {
            "client_id": constants.CLIENT_ID,
            "token": refresh_token,
        }
        headers = {"Content-Type": "application/x-www-form-urlencoded"}

        async with self.__set_is_processing_login():
            try:
                from .create_http_client import create_http_client

                async with create_http_client() as session:
                    async with session.post(
                        constants.REVOKE_TOKEN_ENDPOINT,
                        headers=headers,
                        data=revoke_token_request_data,
                    ) as response:
                        import aiohttp

                        try:
                            response_data = await response.json(content_type=None)  # Raises json.JSONDecodeError
                            response.raise_for_status()  # Raises ClientResponseError or other ClientError
                            return response_data
                        except aiohttp.ClientResponseError as exception:
                            error_description = response_data.get("error_description", None)
                            if error_description:
                                exception.message = error_description
                            raise exception
            finally:
                self.token_data = {}
                self.rbx.is_logged_in = False

    async def refresh_login_if_needed(self):
        refresh_token = self.token_data.get("refresh_token")

        if not refresh_token:
            raise NotLoggedInError("An active login session is required to refresh tokens")

        if (not self.rbx.is_logged_in) or self.token_data.get("refresh_after") < time():
            # Raises ClientResponseError, ClientError, or JSONDecodeError
            async with self.__set_is_processing_login():
                new_token_data = await self.__refresh_tokens(refresh_token)

                # Raises ClientResponseError, ClientError, JSONDecodeError, AttributeError, ValueError, or jwt.exceptions.DecodeError
                from .request_login_details import request_login_details

                self.__complete_login(*await request_login_details(new_token_data))

    def __complete_login(self, creator_ids, preferred_username, group_names_by_id, token_data):
        # Set state values in rbx from the data fetched and processed above
        self.__set_creators_from_ids(creator_ids, preferred_username, group_names_by_id)
        self.preferred_username = preferred_username
        self.token_data = token_data
        self.rbx.is_logged_in = True

    @staticmethod
    def __construct_auth_url(state, code_challenge):
        """
        Constructs an authorization URL for the OAuth2 authorization flow.
        This URL is used in the initial browser GET request to start the authorization process.
        """
        from . import constants

        redirect_uri = f"http://localhost:{PORT}/{constants.RELATIVE_REDIRECT_PATH.lstrip('/')}"
        auth_params = {
            "client_id": constants.CLIENT_ID,
            "redirect_uri": redirect_uri,
            "response_type": RESPONSE_TYPE,
            "scope": " ".join(constants.SCOPES),
            "code_challenge": code_challenge,
            "code_challenge_method": CODE_CHALLENGE_METHOD,
            "state": state,
        }

        auth_url = urljoin(constants.AUTH_CODE_ENDPOINT, "?" + urlencode(auth_params))
        return auth_url

    @asynccontextmanager
    async def __set_is_processing_login(self):
        try:
            self.rbx.is_processing_login_or_logout = True
            yield
        finally:
            self.rbx.is_processing_login_or_logout = False

    async def __refresh_tokens(self, refresh_token):
        """
        Requests new tokens with an existing refresh token. Raises aiohttp.ClientResponseError,
        aiohttp.ClientError, or json.JSONDecodeError if any errors occur. Returns the response data in JSON format.
        """
        from . import constants

        access_token_request_data = {
            "grant_type": "refresh_token",
            "refresh_token": refresh_token,
            "client_id": constants.CLIENT_ID,
        }

        from .create_http_client import create_http_client

        headers = {"Content-Type": "application/x-www-form-urlencoded"}
        async with create_http_client() as session:
            async with session.post(
                constants.REFRESH_TOKEN_ENDPOINT,
                headers=headers,
                data=access_token_request_data,
            ) as response:
                import aiohttp

                try:
                    # Raises json.JSONDecodeError
                    response_data = await response.json()
                    response.raise_for_status()  # Raises ClientResponseError or other ClientError
                    return response_data
                except aiohttp.ClientResponseError as exception:
                    error_description = response_data.get("error_description", None)
                    if error_description:
                        exception.message = error_description
                    raise exception

    def __set_creators_from_ids(self, creator_ids, preferred_username, group_names_by_id):
        """Populates a CollectionProperty with RbxCreatorData objects containing creator types, ids, and names
        given ids and names. Used for persisting creator data across sessions and generating enum dropdown items.
        """
        self.rbx.creators.clear()

        try:
            if creator_ids["user"]:
                creator = self.rbx.creators.add()
                creator.type = "USER"
                creator.id = creator_ids["user"]
                creator.name = preferred_username

            for group_id in creator_ids["groups"]:
                creator = self.rbx.creators.add()
                creator.type = "GROUP"
                creator.id = group_id
                creator.name = group_names_by_id[group_id]
        except Exception:
            # In case adding any creator fails, we clear all creators so the list appears obviously broken
            self.rbx.creators.clear()
            raise
